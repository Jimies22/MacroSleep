/**
 * # Core Philosophy
 * This ruleset enforces a strict user-ownership model. All user-related data,
 * including profiles, sleep logs, and macro logs, is isolated within a
 * user-specific data tree. The core principle is that a user can only access
 * their own information. There is no concept of public or shared data in this model.
 *
 * # Data Structure
 * All data is organized hierarchically under the top-level `/users` collection.
 * Each user's data is stored in a document structure like `/users/{userId}/...`,
 * where `{userId}` corresponds to the user's Firebase Authentication UID.
 * The user's profile is stored at `/users/{userId}`.
 * Specific data types are segregated into their own subcollections:
 * - `/users/{userId}/sleep_logs/{sleepLogId}`: A collection of the user's sleep entries.
 * - `/users/{userId}/macro_logs/{macroLogId}`: A collection of the user's macro entries.
 *
 * # Key Security Decisions
 * - **Strict Ownership**: All rules are based on the `{userId}` path parameter,
 *   ensuring that `request.auth.uid` must match `{userId}` for any access to be granted.
 * - **No Public Access**: All read and write operations require a user to be
 *   authenticated. No data is exposed to unauthenticated users.
 * - **User Privacy**: Listing documents in the top-level `/users` collection is
 *   explicitly forbidden to prevent enumeration of all users in the application.
 * - **Relational Integrity**: On creation, rules validate that the document data
 *   contains an internal ownership field (`uid`) that matches the
 *   `{userId}` from the path. This field is enforced as immutable on updates to
 *   prevent documents from being "re-assigned" to different users.
 *
 * # Denormalization for Authorization
 * This security model primarily relies on path-based ownership, which is highly
 * performant and secure. The `SleepLog` and `MacroLog` documents contain a
 * denormalized `userId` field. The rules leverage this field to enforce a
 * consistent and immutable link between a log entry and its owner, ensuring
 * that the relationship established at creation can never be broken.
 *
 * # Structural Segregation
 * The data model is already structurally segregated by user, which is a highly
 * secure pattern. Each user's data exists in its own isolated path, making it
 * impossible for one user's queries to accidentally leak data from another user.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // =====================================================================
    // Helper Functions
    // =====================================================================

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the given userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * A robust check for update/delete operations, ensuring the user is the
     * owner AND the document they are trying to modify actually exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates a user is creating their own profile document and that the
     * internal 'uid' field correctly references their own UID.
     */
    function isCreatingOwnProfile(userId) {
      return isOwner(userId) && request.resource.data.uid == userId;
    }

    /**
     * Validates a user is updating their own profile and ensures the
     * internal 'uid' field cannot be changed, maintaining relational integrity.
     */
    function isUpdatingOwnImmutableProfile(userId) {
      return isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
    }

    /**
     * Validates a user is creating their own log document (for sleep or macros)
     * and that the internal 'userId' field correctly references their UID.
     */
    function isCreatingOwnLog(userId) {
      return isOwner(userId) && request.resource.data.userId == userId;
    }

    /**
     * Validates a user is updating their own log and ensures the internal 'userId'
     * field cannot be changed, maintaining relational integrity.
     */
    function isUpdatingOwnImmutableLog(userId) {
      return isExistingOwner(userId) && request.resource.data.userId == resource.data.id;
    }


    // =====================================================================
    // Collection Rules
    // =====================================================================

    /**
     * @description Secures the user profile document. Only the owner can
     * read or write their own profile. Listing all users is forbidden.
     * @path /users/{userId}
     * @allow (get, update) User 'abc' reading/updating their own profile: `db.doc('users/abc').get()`.
     * @deny (list) A user trying to list all other users: `db.collection('users').get()`.
     * @deny (create) Creating a user doc without matching UID.
     * @principle Prevents user enumeration and restricts data access to the owner.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow create: if isCreatingOwnProfile(userId);
      allow update: if isUpdatingOwnImmutableProfile(userId);
      allow delete: if isOwner(userId);
      // Deny listing all users for privacy.
      allow list: if false;


      /**
       * @description Secures a user's sleep log entries. Only the owner can
       * create, read, update, or delete their own logs.
       * @path /users/{userId}/sleep_logs/{sleepLogId}
       * @allow (create) User 'abc' creating a new sleep log for themselves.
       * @deny (get) User 'xyz' trying to read one of user 'abc's sleep logs.
       * @principle Enforces document ownership and validates relational
       * integrity by ensuring the `userId` field in the document matches the path.
       */
      match /sleep_logs/{sleepLogId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isCreatingOwnLog(userId);
        allow update: if isUpdatingOwnImmutableLog(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Secures a user's macro log entries. Only the owner can
       * create, read, update, or delete their own logs.
       * @path /users/{userId}/macro_logs/{macroLogId}
       * @allow (list) User 'abc' listing all their past macro logs.
       * @deny (delete) User 'xyz' trying to delete one of user 'abc's macro logs.
       * @principle Enforces document ownership and validates relational
       * integrity by ensuring the `userId` field in the document matches the path.
       */
      match /macro_logs/{macroLogId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isCreatingOwnLog(userId);
        allow update: if isUpdatingOwnImmutableLog(userId);
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}
